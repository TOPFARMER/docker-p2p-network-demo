PBFT步骤：
1. 实现服务器能传递消息
2. 服务器查询publicKey后应有一个缓存表: supervisors{}



### 逻辑：
#### 连接层：
1. 连接时区分server与client，并登记各个server的publicKey
   
   补充：验证环节之后需要加强
2. peers列表收到之后进行排序，用于确定每次发起请求的view id
3. 为什么使用websocket连接？
   全双工，可以设置连接门槛，可以确认消息来源，省去签名计算量。


#### 发信环节
1. 为什么request要向全网广播
   
   首先，我的技术无法实现在没有连接上系统的情况下确定当前系统内部viewId。

   其次，全网广播request可以让非主节点先行计算区块，加快系统运行速度。

2. request校验不需要校验来源，只需要检查审查员的签名是否合法即可。
3. orderedRequest的“减肥”
   
   首先，第一步是根据时间戳直接与本地相同时间戳的区块缓存的区块对照（直接对照哈希即可）。如果本地区块缓存没有这个区块，那么校验信息中附带的request的合法性，合法则生成区块，对照哈希。如此说来，OR的信息只需要主节点自身生成的区块哈希以及request的信息即可。

```
  // 每次先收request能预处理，加快处理时间
  // 需要验证生成的区块是否与本地生成的区块一致
  // 如果本地缓存中没有找到该时间戳的request，说明该block的request还没有收到
  // 此时有两种情况: 1.客户端的request还没送到 2.该block是恶意攻击
  // 判断的情况是：查找blockCache表，如果有则对照两个block
  // 没有则利用orderedRequest发来的request信息（先校验有效性）
  // 然后生成区块，再与发来的block对照
  // 若此后再次收到request，直接生成区块压入即可
  // 因为这个request若为审查员已签的，则生成区块一定与此前通过校验的区块一致
```


4. 其他补充
   
   **为什么一定需要给服务器分配密钥对？**    
  
   密钥对可以辨别发信主机，在出错时能定位拜占庭错误点，恢复主机。同时私钥签名能确保多条消息非同节点所发。（关键在于，连接是socket连接，实际不需要校验身份，即可确定发起主机）

   **关于检查点（checkpoint）?**
   
   检查点(checkpoint)在各种类型的PBFT算法中有不同的称呼（水位、提交证书等），其用途是确认在拜占庭错误发生时，系统中大于2/3的节点所同意的正确区块位置，该位置一旦确立，则说明整个系统在该位置之前的所有区块都是一致的。
   
   原Zyzzyva的实现中，checkpoint在客户端收取正确回应条数```CP(currect reponse)```， ```2f + 1 < CP < 3f + 1```时产生，产生过程为服务器收取客户端发起的commit信息，确认结果后给客户端发回localCommit。
   
   但是原实现在本项目中有其局限性。
   
   首先，若一直没有发生拜占庭错误：
   
   1. 突然，客户端收取有效回复条数 ```CP < 2f + 1```， 由于系统中错误节点必不多于```f```，可认为主节点发生拜占庭错误。发起视图变更，最后确定历史记录时，由于系统中不存在检查点，可以认为迄今为止都一致则无需对照缓存。

   带来的问题是：系统一直都无法清理历史记录缓存，无法进行垃圾回收。

   2. 在一段长时间之前，系统发生过非主节点引起的拜占庭错误。检查点在当前区块前很远的地方，此时一旦发生主节点的拜占庭错误，则需要启动视图变更。在对照历史时，历史记录缓存过于庞大，系统试视图变更过程极其缓慢，效率底下。
   
   **Commit消息的发送时机**

   明确一点，checkpoint是服务于视图改变的。于是该机制在目前项目中施行可以针对性改造。

   接上文，若系统发生拜占庭错误,则客户端向全网广播commit，为了减少客户端（收集器）的计算量，以及commit的数据量，服务器收到commit后各自发送localCommit（包含区块高度，区块哈希以及本机签名）并收集，确认检查点，清理历史记录缓存，生成检查点提交证书（localCommit的签名集合），检查签名的真实性，不回复。

   为避免发生上述情况2,必须提出其他历史记录缓存清理机制：服务器用区块高度定位，检查当前区块高度，如果高度距离上一检查点达到某值，则自动发起localCommit广播，让其他服务器收取证书，同时统计localCommit，并进行历史记录缓存清理，生成检查点提交证书，检查签名的真实性。

   原因解析：如果非拜占庭客户端发出commit，说明客户端本身收到了至少2/3的正确区块，此时不需要服务器往客户端回发localCommit。如果拜占庭客户端发出commit，服务器需要知道当前系统是否有2/3或以上的节点确认该检查点正确，他们需要给各自发送localCommit统计并确认。

   **视图变更**

   视图是不向外暴露的。